library(raster)
library(RColorBrewer)
library(OpenImageR)
library(SuperpixelImageSegmentation)
library(raster)
library(RColorBrewer)


hyperspectral_2019 <- brick("P:/RaBET/Subset/2019/2019_neon_hyperspectral.tif")

region.brick <- brick(b2, b3, b4, b5)

#We will need to save the number of rows and columns for present and future use.
print(nrows <- region.brick@nrows)
print(ncols <- region.brick@ncols)

#Next we plot the region.brick object (shown above) and write it to disk.
# False color image

plotRGB(hyperspectral_2019, r = 4, g = 3, b = 2, stretch = 'lin')


# Write the image to disk
jpeg('FalseColor.jpg', width = ncols, height = nrows)
plotRGB(hyperspectral_2019, r = 4, g = 3, b = 2, stretch = 'lin')
dev.off()
#We will now use SLIC for image segmentation. The code here is adapted directly from the superpixels vignette.

library(OpenImageR)
False.Color <- readImage('FalseColor.jpg')
Region.slic = superpixels(input_image = False.Color, method = 'slic', superpixel = 80,compactness = 30, return_slic_data = TRUE, return_labels = TRUE, write_slic = '',  verbose = FALSE)
#Warning message:
 # The input data has values between 0.000000 and 1.000000. The image-data will be multiplied by the value: 255!
imageShow(Region.slic$slic_data)
#We will discuss the warning message in Section 3. The function imageShow() is part of the OpenImageR package.
#3The OpenImageR function superpixels() creates superpixels, but it does not actually create an image segmentation in the sense that we are using the term is defined in Section 1. This is done by functions in the SuperPixelImageSegmentation package (Mouselimis, 2018), whose discussion is also contained in the superpixels vignette. This package is also described in the Additional Topic. As pointed out there, however, some aspects that make the function well suited for image visualization detract from its usefulness for data analysis, so we won't discuss it further in this post. Instead, we will move directly to data analysis using the OpenImageR package.
#3. Data analysis using superpixels
#To use the functions in the OpenImageR package for data analysis, we must first understand the structure of objects created by these packages. The simple, open structure of the objects generated by the function superpixels() makes it an easy matter to use these objects for our purposes. Before we begin, however, we must discuss a preliminary matter: the difference between a Raster* object and a raster object. In Section 2 we used the function raster() to generate the blue, green, red and IR band objects b2, b3, b4, and b5, and then we used the function brick() to generate the object region.brick. Let's look at the classes of these objects.

str(False.Color)
#It is a three-dimensional array, which can be thought of as a box, analogous to a rectangular Rubik's cube. The 'height' and 'width' of the box are the number of rows and columns respectively in the image and at each value of the height and width the 'depth' is a vector whose three components are the red, green, and blue color values of that cell in the image, scaled to [0,1] by dividing the 8-bit RGB values, which range from 0 to 255, by 255. This is the source of the warning message that accompanied the output of the function superpixels(), which said that the values will be multiplied by 255. For our purposes, however, it means that we can easily analyze images consisting of transformations of these values, such as the NDVI. Since the NDVI is a ratio, it doesn't matter whether the RGB values are normalized or not. For our case the RasterLayer object b5 of the RasterBrick False.Color is the IR band and the object b4 is the R band. Therefore we can compute the NDVI as

NDVI.region <- (hyperspectral_2019$X2019_neon_hyperspectral.16 - hyperspectral_2019$X2019_neon_hyperspectral.10)/(hyperspectral_2019$X2019_neon_hyperspectral.16 + hyperspectral_2019$X2019_neon_hyperspectral.10)

#Since NDVI is a ratio scale quantity, the theoretically best practice is to plot it using a monochromatic representation in which the brightness of the color (i.e., the color value) represents the value (Tufte, 1983). We can accomplish this using the RColorBrewer function brewer.pal().

library(RColorBrewer)
plot(NDVI.region, col = brewer.pal(9, 'Greens'),
          axes = TRUE, main = 'Region NDVI')
#This generates the NDVI map shown above. The darkest areas have the highest NDVI. Let's take a look at the structure of the RasterLayer object NDVI.region.
str(NDVI.region)
NDVI.mat <- matrix(NDVI.region@data@values,
                        nrow = NDVI.region@nrows,
                        ncol = NDVI.region@ncols, byrow = TRUE)

#The function imageShow() works with data that are either in the eight bit 0 - 255 range or in the [0,1] range (i.e., the range of x between and including 0 and 1). It does not, however, work with NDVI values if these values are negative. Therefore, we will scale NDVI values to [0,1].

m0 <- min(NDVI.mat)
m1 <- max(NDVI.mat)
NDVI.mat1 <- (NDVI.mat-m0) / (m1-m0)
imageShow(NDVI.mat)

NDVI.data <- False.Color
NDVI.data[,,1] <- NDVI.mat1
NDVI.data[,,2] <- NDVI.mat1
NDVI.data[,,3] <- NDVI.mat1


NDVI.80 = superpixels(input_image = NDVI.data,
                           method = 'slic', superpixel = 80,
                           compactness = 30, return_slic_data = TRUE,
                           return_labels = TRUE, write_slic = '',
                           verbose = FALSE)
imageShow(Region.slic$slic_data)


str(NDVI.80)

sort(unique(as.vector(NDVI.80$labels)))

R0 <- NDVI.80
for (i in 1:nrow(R0$label))
      for (j in 1:ncol(R0$label))
           if (R0$label[i,j] != 0)
                R0$slic_data[i,j,] <- c(255,255,255)
imageShow(R0$slic_data)


Bdry <- NDVI.80
for (i in 1:nrow(Bdry$label))
      for (j in 1:ncol(Bdry$label))
         if (!(Bdry$slic_data[i,j,1] == 0 &
                     Bdry$slic_data[i,j,2] == 0 &
                       Bdry$slic_data[i,j,3] == 0))
             Bdry$slic_data[i,j,] <- c(255,255,255)
Bdry.norm <- NormalizeObject(Bdry$slic_data)
imageShow(Bdry$slic_data)


NDVI.means <- make (NDVI.80, mean)
imageShow(NDVI.means$slic_data)

sett.seed(123)
NDVI.clus <-
   kmeans(as.vector(NDVI.means$slic_data[,,1]), 5)
vege.class <- matrix(NDVI.clus$cluster,
                           nrow = NDVI.region@nrows,
                           ncol = NDVI.region@ncols, byrow = FALSE)
class.ras <- raster(vege.class, xmn = W,
                          xmx = E, ymn = S, ymx = N, crs =
                            CRS('+proj=utm +zone=10 +ellps=WGS84'))






class.ras <- ratify(class.ras)
rat.class <- levels(class.ras)[[1]]
rat.class$landcover <- c('Water', 'Open',
                            +  'Scrub', Med. Crop', 'Dense Crop')
levels(class.ras) <- rat.class
levelplot(class.ras, margin=FALSE,
   col.regions= c(blue', tan',
                       lightgreen', green', darkgreen'),
    main = Land Cover Types')


The result is shown in the figure at the start of the post. We can also overlay the original boundaries on top of the image. This is more easily done using plot() rather than levelplot(). The function plot() allows plots to be built up in a series of statements. The function levelplot() does not.

NDVI.rasmns <- raster(NDVI.means$slic_data[,,1],
               xmn = W, xmx = E, ymn = S, ymx = N,
               crs = CRS('+proj=utm +zone=10 +ellps=WGS84'))
NDVI.polymns <- rasterToPolygons(NDVI.rasmns,
                          dissolve = TRUE)
plot(class.ras, col = c('blue', 'tan',
                  'lightgreen', 'green', 'darkgreen'),
       +   main = 'Land Cover Types', legend = FALSE)
legend('bottom', legend = c('Water', 'Open',
                      'Scrub', 'Med. Crop', 'Dense Crop'),
 fill = c('blue', 'tan', 'lightgreen', 'green',
               'darkgreen'))
plot(NDVI.polymns, add = TRUE)
